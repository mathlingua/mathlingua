
::some text block::


::some.id
some other text block
::



Theorem:
then:
. equivalently: 'x'
------------------------------------------
Id: "<auto-generated id>"


Theorem:
then:
. allOf: 'x'
------------------------------------------
Id: "<auto-generated id>"


Theorem:
then:
. anyOf: 'x'
------------------------------------------
Id: "<auto-generated id>"


Theorem:
then:
. oneOf: 'x'
------------------------------------------
Id: "<auto-generated id>"


Theorem:
then:
. not: 'x'
------------------------------------------
Id: "<auto-generated id>"


Theorem:
then:
. exists: x
  using: y
  where: 'x is \something'
  suchThat: 'x > 0'
------------------------------------------
Id: "<auto-generated id>"


Theorem:
then:
. existsUnique: x
  using: y
  where: 'x is \something'
  suchThat: 'x > 0'
------------------------------------------
Id: "<auto-generated id>"


Theorem:
then:
. forAll: x
  using: y
  where: 'x is \something'
  suchThat: 'x > 0'
  then: 'x is \something.else'
------------------------------------------
Id: "<auto-generated id>"


Theorem:
then:
. declare: x
  using: y
  where: 'x is \something'
  suchThat: 'x > 0'
  then: 'x is \something.else'
------------------------------------------
Id: "<auto-generated id>"


Theorem:
then:
. if: 'p'
  then: 'q'
------------------------------------------
Id: "<auto-generated id>"


Theorem:
then:
. iff: 'p'
  then: 'q'
------------------------------------------
Id: "<auto-generated id>"


[\some.function(x)]
Defines: f(x)
means: 'f is \function'
expresses:
. piecewise:
  if: 'x > 0'
  then: 'f(x) := 1'
  elseIf: 'x < 0'
  then: 'f(x) := -1'
  else: 'f(x) := 0'
------------------------------------------
Id: "<auto-generated id>"


[\x]
Defines: G := (X, *, e)
expresses:
. '"*" is \binary.operator'
. 'x * y := 0'
------------------------------------------
Id: "<auto-generated id>"


[\something1]
Describes: X
extends:
. when: 'X extends \something2'
  then: 'X is \something2'
specifies: 'X is \something3'
------------------------------------------
Id: "<auto-generated id>"


[\something2{a}:of{b, c}:and{d}]
Describes: X(x)
using: A
when:
. 'b, c is \something'
. 'a is \something2{b, c}'
. 'd is \something3{a, A}'
suchThat:
. 'a, b, c, d > 0'
extends: 'X is \something.else'
specifies: 'X > 0'
Provides:
. 'x + y :=> x \{plus}/ y'
. 'x [.in.]: X :-> x is \element:of{X}'
. 'a [.middle.] b :=> a * b'
. 'a :[.left.] b :=> a * b'
. 'a [.right.]: b :=> a * b'
. symbol: 'x - y :=> x \{minus}/ y'
  replaces: 'x * y'
  written: "x? -- y?"
. view:
  as: A
  using: B, C
  where: 'A is \something{B, C}'
  through: 'A := \something2.asSomething{X}'
  signifies: 'A is \isomorphic.to{\B}'
. encoding:
  as: A
  using: B, C
  where: 'A is \something{B, C}'
  through: 'A := \something2.asSomething{X}'
Justified:
. by: "\:some.theorem"
. label: "\(some.label)"
  by: "\:some.other.theorem"
Documented:
. written: "X?(x?)"
. called: "some name"
. writing: "X?"
. overview: "some overview in Markdown"
. related: "\:some.item"
References:
. "$some.reference"
. "$some.other.reference:page{1}"
Aliases:
. 'x ++ y :=> x \{plus.plus}/ y'
. 'x [.within.]: X :-> x \[within]/ X'
------------------------------------------
Id: "<auto-generated id>"


[\something3{a}:of{b, c}:and{d}]
Defines: X(x)
using: A
when:
. 'b, c is \something'
. 'a is \something2{b, c}'
. 'd is \something3{a, A}'
suchThat:
. 'a, b, c, d > 0'
means: 'X is \something.else'
expresses: 'X(x) := 0'
Provides:
. 'x + y :=> x \{plus}/ y'
. 'x [.in.]: X :-> x is \element:of{X}'
. symbol: 'x - y :=> x \{minus}/ y'
  written: "x? -- y?"
. view:
  as: A
  using: B, C
  where: 'A is \something{B, C}'
  through: 'A := \something2.asSomething{X}'
  signifies: 'A is \isomorphic.to{\B}'
Justified:
. by: "\:some.theorem"
. label: "\(some.label)"
  by: "\:some.other.theorem"
Documented:
. written: "X?(x?)"
. called: "some name"
. writing: "X?"
. overview: "some overview in Markdown"
. related: "\:some.item"
References:
. "$some.reference"
. "$some.other.reference:page{1}"
Aliases:
. 'x ++ y :=> x \{plus.plus}/ y'
. 'x [.within.]: X :-> x \[within]/ X'
------------------------------------------
Id: "<auto-generated id>"


[\integral[x...]{f(x...)}]
Captures:
. '\real.integral[x]{f(x)}'
. '\double.integral[x, y]{f(x, y)}'
. '\triple.integral[x, y, z]{f(x, y, z)}'
. '\general.integral[x...]{f(x...)}'
Justified:
. by: "\:some.theorem"
. label: "\(some.label)"
  by: "\:some.other.theorem"
Documented:
. written: "X?(x?)"
. called: "some name"
. writing: "X?"
. overview: "some overview in Markdown"
. related: "\:some.item"
References:
. "$some.reference"
. "$some.other.reference:page{1}"
------------------------------------------
Id: "<auto-generated id>"


[A \{something.infix}/ B]
States:
using: U
when: 'A, B is \something:using{U}'
suchThat:
. 'A, B is \something'
that:
. 'A, B > 0'
Justified:
. by: "\:some.theorem"
. label: "\(some.label)"
  by: "\:some.other.theorem"
Documented:
. written: "X?(x?)"
. called: "some name"
. writing: "X?"
. overview: "some overview in Markdown"
. related: "\:some.item"
References:
. "$some.reference"
. "$some.other.reference:page{1}"
Aliases:
. 'x ++ y :=> x \{plus.plus}/ y'
. 'x [.within.]: X :-> x \[within]/ X'
------------------------------------------
Id: "<auto-generated id>"


Specify:
. positiveInt: x
  means: 'x is \something'
. negativeInt: x
  means: 'x is \something'
. zero:
  means: '0 := \something.0'
. positiveFloat: x
  means: 'x is \something'
. negativeFloat: x
  means: 'x is \something'
------------------------------------------
Id: "<auto-generated id>"


[\some.theorem]
Theorem:
given: x
using: y
where: 'x is \something'
if: 'x > 0'
then: 'x >= 0'
Proof:
. "\:some.proof"
. "some inline proof"
Documented:
. written: "X?(x?)"
. called: "some name"
. writing: "X?"
. overview: "some overview in Markdown"
. related: "\:some.item"
References:
. "$some.reference"
. "$some.other.reference:page{1}"
Aliases:
. 'x ++ y :=> x \{plus.plus}/ y'
. 'x [.within.]: X :-> x \[within]/ X'
------------------------------------------
Id: "<auto-generated id>"


[\some.corollary]
Corollary:
to:
. "\:some.theorem"
. "\:some.other.theorem"
given: x
using: y
where: 'x is \something'
if: 'x > 0'
then: 'x >= 0'
Proof:
. "\:some.proof"
. "some inline proof"
Documented:
. written: "X?(x?)"
. called: "some name"
. writing: "X?"
. overview: "some overview in Markdown"
. related: "\:some.item"
References:
. "$some.reference"
. "$some.other.reference:page{1}"
Aliases:
. 'x ++ y :=> x \{plus.plus}/ y'
. 'x [.within.]: X :-> x \[within]/ X'
------------------------------------------
Id: "<auto-generated id>"


[\some.lemma]
Lemma:
for:
. "\:some.theorem"
. "\:some.other.theorem"
given: x
using: y
where: 'x is \something'
if: 'x > 0'
then: 'x >= 0'
Proof:
. "\:some.proof"
. "some inline proof"
Documented:
. written: "X?(x?)"
. called: "some name"
. writing: "X?"
. overview: "some overview in Markdown"
. related: "\:some.item"
References:
. "$some.reference"
. "$some.other.reference:page{1}"
Aliases:
. 'x ++ y :=> x \{plus.plus}/ y'
. 'x [.within.]: X :-> x \[within]/ X'
------------------------------------------
Id: "<auto-generated id>"


[\some.theorem2]
Theorem:
given: x
where: 'x is \something'
iff: 'x > 0'
then: 'x >= 0'
------------------------------------------
Id: "<auto-generated id>"


[\some.axiom]
Axiom:
given: x
using: y
where: 'x is \something'
if: 'x > 0'
then: 'x >= 0'
Documented:
. written: "X?(x?)"
. called: "some name"
. writing: "X?"
. overview: "some overview in Markdown"
. related: "\:some.item"
References:
. "$some.reference"
. "$some.other.reference:page{1}"
Aliases:
. 'x ++ y :=> x \{plus.plus}/ y'
. 'x [.within.]: X :-> x \[within]/ X'
------------------------------------------
Id: "<auto-generated id>"


[\some.axiom2]
Axiom:
given: x
where: 'x is \something'
iff: 'x > 0'
then: 'x >= 0'
------------------------------------------
Id: "<auto-generated id>"


[\some.conjecture]
Conjecture:
given: x
using: y
where: 'x is \something'
if: 'x > 0'
then: 'x >= 0'
Documented:
. written: "X?(x?)"
. called: "some name"
. writing: "X?"
. overview: "some overview in Markdown"
. related: "\:some.item"
References:
. "$some.reference"
. "$some.other.reference:page{1}"
Aliases:
. 'x ++ y :=> x \{plus.plus}/ y'
. 'x [.within.]: X :-> x \[within]/ X'
------------------------------------------
Id: "<auto-generated id>"


[\some.conjecture2]
Conjecture:
given: x
where: 'x is \something'
iff: 'x > 0'
then: 'x >= 0'
------------------------------------------
Id: "<auto-generated id>"


[@some.person]
Person:
. name:
  . "some name"
  . "some other name"
. biography: "some content"
------------------------------------------
Id: "<auto-generated id>"


[$some.resource]
Resource:
. title: "some title"
. author:
  . "@author1"
  . "@author2"
. offset: "1"
. url: "some/url"
. homepage: "some/homepage"
. type: "book"
. editor:
  . "@editor1"
  . "@editor2"
. edition: "1"
. institution:
  . "institution 1"
  . "institution 2"
. journal:
  . "journal1"
  . "journal2"
. publisher:
  . "publisher 1"
  . "publisher 2"
. volume: "1"
. month: "January"
. year: "2023"
. description: "some description"
------------------------------------------
Id: "a9ec758e-4755-4173-9d25-4081c03c83dd"


Theorem:
if: 'a'     (1)
then: 'b'   (some.label)
------------------------------------------
Id: "<auto-generated id>"


Theorem:
if: 'a'  (1), 'b'  (2)
then: 'b'   (some.label)
------------------------------------------
Id: "<auto-generated id>"


Theorem:
given: a
if:
. 'a is \\formulation{statement|expression|specification}'
. 'a is \\type{\:function & \:set}'
. 'a is \\formulation{statement}'
. 'a is \\type{\:function}'
. 'a is \\type{\:set \:{in}:/ \:set}'
. 'a is \\formulation'
. 'a is \\type'
. 'b := \\select{statement}:from{x}'
. 'c := \\select{statement|expression}:from{x}'
. 'd := \\select{statement|expression|specification}:from{x}'
. 'f(\\map{x[i]}:to{x[i] + 1})'
. 'a... := \\map{x[i[k]]}:to{x[i[k]] + 1}:else{a + 1}'
. 'x[i...]'
. 'x[i...n]'
. 'x[(i, j)...(m, n)]'
then: 'a'
------------------------------------------
Id: "<auto-generated id>"


Theorem:
then:
. exists: x
  suchThat: "something"
------------------------------------------
Id: "<auto-generated id>"


Theorem:
then:
. exists: x
  suchThat: "something"
Proof:
. "something"
. 'x > 0'
. equivalently:
  . "abc"
  . "xyz"
. allOf:
  . "abc"
  . "xyz"
. not:
  . "abc"
. anyOf:
  . "abc"
  . "xyz"
. oneOf:
  . "abc"
  . "xyz"
. exists: x
  suchThat: "something"
. existsUnique: x
  suchThat: "something"
. forAll: x
  then: "something"
. declare: x
  then: "something"
. if: "a"
  then: "b"
. iff: "a"
  then: "b"
. then: "something"
. thus: "something"
. therefore: "something"
. hence: "something"
. notice: "something"
. next: "something"
. then: "something"
  by: "\(something)"
. thus: "something"
  by: "\(something)"
. therefore: "something"
  by: "\(something)"
. hence: "something"
  by: "\(something)"
. notice: "something"
  by: "\(something)"
. next: "something"
  by: "\(something)"
. then: "something"
  because: "something"
. thus: "something"
  because: "something"
. therefore: "something"
  because: "something"
. hence: "something"
  because: "something"
. notice: "something"
  because: "something"
. next: "something"
  because: "something"
. by: "\(something)"
  then: "something"
. because: "something"
  then: "something"
. stepwise:
  . "abc"
  . "xyz"
. suppose: "abc"
  then: "xyz"
. block:
  . 'abc := xyz'
. remark: "some remark"
. casewise:
  case: "abc"
  case: "xyz"
  else: "x"
. withoutLossOfGenerality:
  . "abc"
  . 'xyz'
. qed:
. absurd:
. done:
. contradiction:
. forContradiction:
  . 'a'
. forInduction:
  . 'b'
. forContrapositive:
  . 'c'
. sufficesToShow:
  . 'd'
. toShow:
  . 'x'
  observe:
  . 'y'
. partwise:
  part:
  . 'a'
  part:
  . 'b'
  part:
  . 'c'
. claim:
  given: x
  using: y
  where: 'y is \y'
  suchThat: 'x > 0'
  if: 'y > 0'
  then: 'y > 0'
. equivalently:
  . block: 'x = y'
. allOf:
  . block: 'x = y'
. not:
  . block: 'x = y'
. anyOf:
  . block: 'x = y'
. oneOf:
  . block: 'x = y'
. exists: x
  suchThat:
  . block: 'x = y'
. existsUnique: x
  suchThat:
  . block: 'x = y'
. forAll: x
  suchThat:
  . block: 'x = y'
  then:
  . block: 'x = y'
. declare: x
  suchThat:
  . block: 'x = y'
  then:
  . block: 'x = y'
. if:
  . block: 'x = y'
  then:
  . block: 'x = y'
. iff:
  . block: 'x = y'
  then:
  . block: 'x = y'
------------------------------------------
Id: "<auto-generated id>"


Axiom:
given: x, y
using: a, b
where: 'x, y is \something{a, b}'
suchThat:
. 'x > 0'
. 'y > 0'
iff: 'x is \something'
then: 'y is \something'
------------------------------------------
Id: "<auto-generated id>"


Theorem:
given: x, y
using: a, b
where: 'x, y is \something{a, b}'
suchThat:
. 'x > 0'
. 'y > 0'
iff: 'x is \something'
then: 'y is \something'
------------------------------------------
Id: "<auto-generated id>"


Conjecture:
given: x, y
using: a, b
where: 'x, y is \something{a, b}'
suchThat:
. 'x > 0'
. 'y > 0'
iff: 'x is \something'
then: 'y is \something'
------------------------------------------
Id: "<auto-generated id>"


Lemma:
for: "\some.theorem"
given: x, y
using: a, b
where: 'x, y is \something{a, b}'
suchThat:
. 'x > 0'
. 'y > 0'
iff: 'x is \something'
then: 'y is \something'
------------------------------------------
Id: "<auto-generated id>"


Corollary:
to: "\some.theorem"
given: x, y
using: a, b
where: 'x, y is \something{a, b}'
suchThat:
. 'x > 0'
. 'y > 0'
iff: 'x is \something'
then: 'y is \something'
------------------------------------------
Id: "<auto-generated id>"
