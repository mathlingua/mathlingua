::some text block::



::some.id
some other text block
::



Theorem:
then:
. equivalently: 'x'
Id: "<auto-generated id>"


Theorem:
then:
. allOf: 'x'
Id: "<auto-generated id>"


Theorem:
then:
. anyOf: 'x'
Id: "<auto-generated id>"


Theorem:
then:
. oneOf: 'x'
Id: "<auto-generated id>"


Theorem:
then:
. not: 'x'
Id: "<auto-generated id>"


Theorem:
then:
. exists: x
  using: y
  where: 'x is \something'
  suchThat: 'x > 0'
Id: "<auto-generated id>"


Theorem:
then:
. existsUnique: x
  using: y
  where: 'x is \something'
  suchThat: 'x > 0'
Id: "<auto-generated id>"


Theorem:
then:
. forAll: x
  using: y
  where: 'x is \something'
  suchThat: 'x > 0'
  then: 'x is \something.else'
Id: "<auto-generated id>"


Theorem:
then:
. declare: x
  using: y
  where: 'x is \something'
  suchThat: 'x > 0'
  then: 'x is \something.else'
Id: "<auto-generated id>"


Theorem:
then:
. if: 'p'
  then: 'q'
Id: "<auto-generated id>"


Theorem:
then:
. iff: 'p'
  then: 'q'
Id: "<auto-generated id>"


[\some.function(x)]
Defines: f(x)
means: 'f is \function'
specifies: 'f is \something'
expresses:
. piecewise:
  if: 'x > 0'
  then: 'f(x) := 1'
  elseIf: 'x < 0'
  then: 'f(x) := -1'
  else: 'f(x) := 0'
Id: "<auto-generated id>"


[\x]
Defines: G := (X, *, e)
expresses:
. '"*" is \binary.operator'
. 'x * y := 0'
Id: "<auto-generated id>"


[\something1]
Describes: X
specifies: 'X is \something'
satisfies:
. asserting: 'X == Y'
  then: 'X is \something2'
Id: "<auto-generated id>"


[\something2{a}:of{b, c}:and{d}]
Describes: X(x)
using: A
when:
. 'b, c is \something'
. 'a is \something2{b, c}'
. 'd is \something3{a, A}'
suchThat:
. 'a, b, c, d > 0'
extends: 'X is \something.else'
satisfies: 'X > 0'
Provides:
. 'x + y :=> x \.plus./ y'
. 'x [.in.]: X :-> x is \element:of{X}'
. 'a [.middle.] b :=> a * b'
. 'a :[.left.] b :=> a * b'
. 'a [.right.]: b :=> a * b'
. symbol: 'x - y :=> x \.minus./ y'
  tracks: 'G."-"'
  replaces: 'x * y'
  written: "x? -- y?"
. view:
  as: A
  using: B, C
  where: 'A is \something{B, C}'
  through: 'A := \something2.asSomething{X}'
  signifies: 'A is \isomorphic.to{\B}'
. encoding:
  as: A
  using: B, C
  where: 'A is \something{B, C}'
  through: 'A := \something2.asSomething{X}'
. comparison: "\function:on{A}:to{B} is \function:on{X}:to{Y}"
  provided:
  . "X is A"
  . "B is Y"
Justified:
. by: "\:some.theorem"
. label: "\(some.label)"
  by: "\:some.other.theorem"
Documented:
. written: "X?(x?)"
. called: "some name"
. writing: "X?"
. overview: "some overview in Markdown"
. related: "\:some.item"
References:
. "$some.reference"
. "$some.other.reference:page{1}"
Aliases:
. 'x ++ y :=> x \.plus.plus./ y'
. 'x [.within.]: X :-> x \.within./ X'
Id: "<auto-generated id>"


[\something3{a}:of{b, c}:and{d}]
Defines: X(x)
using: A
when:
. 'b, c is \something'
. 'a is \something2{b, c}'
. 'd is \something3{a, A}'
suchThat:
. 'a, b, c, d > 0'
means: 'X is \something.else'
expresses: 'X(x) := 0'
Provides:
. 'x + y :=> x \.plus./ y'
. 'x [.in.]: X :-> x is \element:of{X}'
. symbol: 'x - y :=> x \.minus./ y'
  written: "x? -- y?"
. view:
  as: A
  using: B, C
  where: 'A is \something{B, C}'
  through: 'A := \something2.asSomething{X}'
  signifies: 'A is \isomorphic.to{\B}'
Justified:
. by: "\:some.theorem"
. label: "\(some.label)"
  by: "\:some.other.theorem"
Documented:
. written: "X?(x?)"
. called: "some name"
. writing: "X?"
. overview: "some overview in Markdown"
. related: "\:some.item"
References:
. "$some.reference"
. "$some.other.reference:page{1}"
Aliases:
. 'x ++ y :=> x \.plus.plus./ y'
. 'x [.within.]: X :-> x \.within./ X'
Id: "<auto-generated id>"


[\integral[x...]{f(x...)}]
Captures:
. '\real.integral[x]{f(x)}'
. '\double.integral[x, y]{f(x, y)}'
. '\triple.integral[x, y, z]{f(x, y, z)}'
. '\general.integral[x...]{f(x...)}'
Justified:
. by: "\:some.theorem"
. label: "\(some.label)"
  by: "\:some.other.theorem"
Documented:
. written: "X?(x?)"
. called: "some name"
. writing: "X?"
. overview: "some overview in Markdown"
. related: "\:some.item"
References:
. "$some.reference"
. "$some.other.reference:page{1}"
Id: "<auto-generated id>"


[A \.something.infix./ B]
States:
using: U
when: 'A, B is \something:using{U}'
suchThat:
. 'A, B is \something'
specifies: 'A is \something'
that:
. 'A, B > 0'
Justified:
. by: "\:some.theorem"
. label: "\(some.label)"
  by: "\:some.other.theorem"
Documented:
. written: "X?(x?)"
. called: "some name"
. writing: "X?"
. overview: "some overview in Markdown"
. related: "\:some.item"
References:
. "$some.reference"
. "$some.other.reference:page{1}"
Aliases:
. 'x ++ y :=> x \.plus.plus./ y'
. 'x [.within.]: X :-> x \.within./ X'
Id: "<auto-generated id>"


Specify:
. positiveInt: x
  means: 'x is \something'
. negativeInt: x
  means: 'x is \something'
. zero:
  means: '0 := \something.0'
. positiveFloat: x
  means: 'x is \something'
. negativeFloat: x
  means: 'x is \something'
Id: "<auto-generated id>"


[\some.theorem]
Theorem:
given: x
declaring: a
using: y
where: 'x is \something'
if: 'x > 0'
then: 'x >= 0'
Proof:
. "\:some.proof"
. "some inline proof"
Documented:
. written: "X?(x?)"
. called: "some name"
. writing: "X?"
. overview: "some overview in Markdown"
. related: "\:some.item"
References:
. "$some.reference"
. "$some.other.reference:page{1}"
Aliases:
. 'x ++ y :=> x \.plus.plus./ y'
. 'x [.within.]: X :-> x \.within./ X'
Id: "<auto-generated id>"


[\some.corollary]
Corollary:
to:
. "\:some.theorem"
. "\:some.other.theorem"
given: x
using: y
where: 'x is \something'
if: 'x > 0'
then: 'x >= 0'
Proof:
. "\:some.proof"
. "some inline proof"
Documented:
. written: "X?(x?)"
. called: "some name"
. writing: "X?"
. overview: "some overview in Markdown"
. related: "\:some.item"
References:
. "$some.reference"
. "$some.other.reference:page{1}"
Aliases:
. 'x ++ y :=> x \.plus.plus./ y'
. 'x [.within.]: X :-> x \.within./ X'
Id: "<auto-generated id>"


[\some.lemma]
Lemma:
for:
. "\:some.theorem"
. "\:some.other.theorem"
given: x
declaring: a
using: y
where: 'x is \something'
if: 'x > 0'
then: 'x >= 0'
Proof:
. "\:some.proof"
. "some inline proof"
Documented:
. written: "X?(x?)"
. called: "some name"
. writing: "X?"
. overview: "some overview in Markdown"
. related: "\:some.item"
References:
. "$some.reference"
. "$some.other.reference:page{1}"
Aliases:
. 'x ++ y :=> x \.plus.plus./ y'
. 'x [.within.]: X :-> x \.within./ X'
Id: "<auto-generated id>"


[\some.theorem2]
Theorem:
given: x
where: 'x is \something'
iff: 'x > 0'
then: 'x >= 0'
Id: "<auto-generated id>"


[\some.axiom]
Axiom:
given: x
declaring: a
using: y
where: 'x is \something'
if: 'x > 0'
then: 'x >= 0'
Documented:
. written: "X?(x?)"
. called: "some name"
. writing: "X?"
. overview: "some overview in Markdown"
. related: "\:some.item"
References:
. "$some.reference"
. "$some.other.reference:page{1}"
Aliases:
. 'x ++ y :=> x \.plus.plus./ y'
. 'x [.within.]: X :-> x \.within./ X'
Id: "<auto-generated id>"


[\some.axiom2]
Axiom:
given: x
where: 'x is \something'
iff: 'x > 0'
then: 'x >= 0'
Id: "<auto-generated id>"


[\some.conjecture]
Conjecture:
given: x
declaring: a
using: y
where: 'x is \something'
if: 'x > 0'
then: 'x >= 0'
Documented:
. written: "X?(x?)"
. called: "some name"
. writing: "X?"
. overview: "some overview in Markdown"
. related: "\:some.item"
References:
. "$some.reference"
. "$some.other.reference:page{1}"
Aliases:
. 'x ++ y :=> x \.plus.plus./ y'
. 'x [.within.]: X :-> x \.within./ X'
Id: "<auto-generated id>"


[\some.conjecture2]
Conjecture:
given: x
where: 'x is \something'
iff: 'x > 0'
then: 'x >= 0'
Id: "<auto-generated id>"


[@some.person]
Person:
. name:
  . "some name"
  . "some other name"
. biography: "some content"
Id: "<auto-generated id>"


[$some.resource]
Resource:
. title: "some title"
. author:
  . "@author1"
  . "@author2"
. offset: "1"
. url: "some/url"
. homepage: "some/homepage"
. type: "book"
. editor:
  . "@editor1"
  . "@editor2"
. edition: "1"
. institution:
  . "institution 1"
  . "institution 2"
. journal:
  . "journal1"
  . "journal2"
. publisher:
  . "publisher 1"
  . "publisher 2"
. volume: "1"
. month: "January"
. year: "2023"
. description: "some description"
Id: "a9ec758e-4755-4173-9d25-4081c03c83dd"


Theorem:
if: 'a'     (1)
then: 'b'     (some.label)
Id: "<auto-generated id>"


Theorem:
if: 'a'     (1), 'b'     (2)
then: 'b'     (some.label)
Id: "<auto-generated id>"


Theorem:
given: a
if:
. 'a is \\abstract'
. 'a is \\specification'
. 'a is \\statement'
. 'a is \\expression'
. 'a is \\type'
. 'x{i...}'
. 'x{i...n}'
. 'x{(i, j)...(m, n)}'
then: 'a'
Id: "<auto-generated id>"


Theorem:
then:
. exists: x
  suchThat: "something"
Id: "<auto-generated id>"


Theorem:
then:
. exists: x
  suchThat: "something"
Proof:
. "something"
. 'x > 0'
. equivalently:
  . "abc"
  . "xyz"
. allOf:
  . "abc"
  . "xyz"
. not:
  . "abc"
. anyOf:
  . "abc"
  . "xyz"
. oneOf:
  . "abc"
  . "xyz"
. exists: x
  suchThat: "something"
. existsUnique: x
  suchThat: "something"
. forAll: x
  then: "something"
. declare: x
  then: "something"
. if: "a"
  then: "b"
. iff: "a"
  then: "b"
. then: "something"
. thus: "something"
. therefore: "something"
. hence: "something"
. notice: "something"
. next: "something"
. then: "something"
  by: "\(something)"
. thus: "something"
  by: "\(something)"
. therefore: "something"
  by: "\(something)"
. hence: "something"
  by: "\(something)"
. notice: "something"
  by: "\(something)"
. next: "something"
  by: "\(something)"
. then: "something"
  because: "something"
. thus: "something"
  because: "something"
. therefore: "something"
  because: "something"
. hence: "something"
  because: "something"
. notice: "something"
  because: "something"
. next: "something"
  because: "something"
. by: "\(something)"
  then: "something"
. because: "something"
  then: "something"
. stepwise:
  . "abc"
  . "xyz"
. suppose: "abc"
  then: "xyz"
. block:
  . 'abc := xyz'
. remark: "some remark"
. casewise:
  case: "abc"
  case: "xyz"
  else: "x"
. withoutLossOfGenerality:
  . "abc"
  . 'xyz'
. qed:
. absurd:
. done:
. contradiction:
. forContradiction:
  . 'a'
. forInduction:
  . 'b'
. forContrapositive:
  . 'c'
. sufficesToShow:
  . 'd'
. toShow:
  . 'x'
  observe:
  . 'y'
. partwise:
  part:
  . 'a'
  part:
  . 'b'
  part:
  . 'c'
. claim:
  given: x
  using: y
  where: 'y is \y'
  suchThat: 'x > 0'
  if: 'y > 0'
  then: 'y > 0'
. equivalently:
  . block: 'x = y'
. allOf:
  . block: 'x = y'
. not:
  . block: 'x = y'
. anyOf:
  . block: 'x = y'
. oneOf:
  . block: 'x = y'
. exists: x
  suchThat:
  . block: 'x = y'
. existsUnique: x
  suchThat:
  . block: 'x = y'
. forAll: x
  suchThat:
  . block: 'x = y'
  then:
  . block: 'x = y'
. declare: x
  suchThat:
  . block: 'x = y'
  then:
  . block: 'x = y'
. if:
  . block: 'x = y'
  then:
  . block: 'x = y'
. iff:
  . block: 'x = y'
  then:
  . block: 'x = y'
Id: "<auto-generated id>"


Axiom:
given: x, y
using: a, b
where: 'x, y is \something{a, b}'
suchThat:
. 'x > 0'
. 'y > 0'
iff: 'x is \something'
then: 'y is \something'
Id: "<auto-generated id>"


Theorem:
given: x, y
using: a, b
where: 'x, y is \something{a, b}'
suchThat:
. 'x > 0'
. 'y > 0'
iff: 'x is \something'
then: 'y is \something'
Id: "<auto-generated id>"


Conjecture:
given: x, y
using: a, b
where: 'x, y is \something{a, b}'
suchThat:
. 'x > 0'
. 'y > 0'
iff: 'x is \something'
then: 'y is \something'
Id: "<auto-generated id>"


Lemma:
for: "\some.theorem"
given: x, y
using: a, b
where: 'x, y is \something{a, b}'
suchThat:
. 'x > 0'
. 'y > 0'
iff: 'x is \something'
then: 'y is \something'
Id: "<auto-generated id>"


Corollary:
to: "\some.theorem"
given: x, y
declaring: a
using: a, b
where: 'x, y is \something{a, b}'
suchThat:
. 'x > 0'
. 'y > 0'
iff: 'x is \something'
then: 'y is \something'
Id: "<auto-generated id>"


[\natural]
Describes: n
satisfies:
. inductively:
  oneOf:
  . case: 'n := \natural.0'
  . case: 'n := \natural.succ(m)'
    using: m
Documented:
. called: "natural number"
Id: "<auto-generated id>"


[n \.natural.+./ m]
Defines: n + m
when: 'n, m is \natural'
expresses:
. matching: n
  as: '\:natural'
  against:
  . case: 'n := 0'
    then: 'n + m := m'
  . case: 'n := k++'
    using: k
    then: 'n + m := (k + m)++'
Documented:
. written: "n? + m?"
. called: "natural addition of $n?$ and $m?$"
Id: "<auto-generated id>"


[n \.natural.+./ m]
Defines: n + m
when: 'n, m is \natural'
expresses:
. matching: n, m
  against:
  . case:
    . 'n := 0'
    . 'm := 0'
    then: 'n + m := m'
  . case: 'n := k++'
    using: k
    then: 'n + m := (k + m)++'
Documented:
. written: "n? + m?"
. called: "natural addition of $n?$ and $m?$"
Id: "<auto-generated id>"


[\f{x}:d{$x}:d{$y...}]
Describes: X
specifies: 'X is \something'
satisfies:
. exists: $z
  suchThat: '$x = $z'
Id: "<auto-generated id>"


Theorem:
given: f[x, y]
then: 'f[x, y] = 0'
Id: "<auto-generated id>"


